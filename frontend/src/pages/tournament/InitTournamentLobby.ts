import { Player } from "./TournamentEngine";
import { Mode, myName, myPlayer, shuffle, ensureMeFirst, sortForRender, byId, currentMax } from "./utils";
import { verifyUserForTournament } from "../../services/api";
import { t } from "../../services/lang/LangEngine";
import DOMPurify from "dompurify";

/**
 * Tournament Lobby Initialization and Management
 *
 * This module handles the tournament lobby interface including:
 * - Player management (adding friends and guests)
 * - Tournament mode selection (2-player or 4-player)
 * - Match preview generation and display
 * - Tournament seed creation and navigation
 * - UI state management and validation
 */

// Local state management
let paired = false;                       // Flag: were pairs generated by clicking Matchmaking?
let plannedPairs: [Player, Player][] | null = null; // 4-player preview pairs (randomized semis)
let players: Player[] = [];               // Current tournament participants
let mode: Mode = "2";                     // Tournament mode (2 or 4 players)
export let difficulty: "easy" | "medium" | "hard" = "medium"; // Tournament difficulty

/**
 * Resets difficulty to default medium setting
 * Called when tournament finishes or when leaving tournament pages
 */
export function resetDifficulty() {
  difficulty = "medium";
}

/**
 * Gets display name for a player, adding "(G)" suffix for guests
 * @param player - Player object
 * @returns Display name with guest indicator if applicable
 */
export function getDisplayName(player: Player): string {
  return player.isAuthenticated ? player.name : `${player.name} (G)`;
}

// Tournament pairing and match generation
/**
 * - Generates semifinal pairings for 4-player tournaments
 * - Always places the current user in the first semifinal
 * - Randomizes the other three players for fair matchups
 * @returns {[Player, Player][]} Array of semifinal pairs
 */
function buildFourPlayerPairs(): [Player, Player][] {
  const me = myPlayer();
  const rest = players
    .filter(p => p.name.toLowerCase() !== me.name.toLowerCase()) // username Tina not equal with tina guest
    .slice(0, 3); // safety
  const bag = shuffle(rest); // Randomize the other three players

  if (bag.length < 3) return []; // Not enough players for 4-player tournament

  const semi1: [Player, Player] = [me, bag[0]!]; // Current user always in first semifinal
  const semi2: [Player, Player] = [bag[1]!, bag[2]!]; // Other two players in second semifinal
  return [semi1, semi2];
}

// UI state management and validation

/**
 * Counts from "count" 0 until "max" 4 from TournamentLobby.ts
 */
function updateCounters() {
  const max = currentMax(mode);
  byId<HTMLSpanElement>("count").textContent = String(players.length);
  byId<HTMLSpanElement>("max").textContent = String(max);

  // take matchmakeing button
  const startBtn = byId<HTMLButtonElement>("btn-start");

  // if at capacity
  const isFull = players.length >= max;

  // disable the start buttin unless the lobby is full
  startBtn.disabled = !isFull;

  // Disable "add" buttons if we're at capacity
  const addGuestBtn = byId<HTMLButtonElement>("btn-add-guest");
  const addUserBtn = byId<HTMLButtonElement>("btn-add-user");
  addGuestBtn.disabled = isFull;
  addUserBtn.disabled = isFull;

  // Disable toggle buttons if we're at capacity
  const toggleGuestBtn = byId<HTMLButtonElement>("btn-toggle-guest");
  const toggleUserBtn = byId<HTMLButtonElement>("btn-toggle-user");
  toggleGuestBtn.disabled = isFull;
  toggleUserBtn.disabled = isFull;

  // Disable input fields if we're at capacity
  const guestNameInput = byId<HTMLInputElement>("guest-name");
  const userEmailInput = byId<HTMLInputElement>("user-email");
  const userPasswordInput = byId<HTMLInputElement>("user-password");
  guestNameInput.disabled = isFull;
  userEmailInput.disabled = isFull;
  userPasswordInput.disabled = isFull;

  // if(isFull) add visual feedback by reducing opacity, block hover and click, else: when not full, restore normal visuals
  if (isFull) {
    // Use inline styles to guarantee override, force the look regardless of CSS precedence
    addGuestBtn.style.opacity = '0.5';
    addGuestBtn.style.cursor = 'not-allowed';
    addGuestBtn.style.pointerEvents = 'none';

    addUserBtn.style.opacity = '0.5';
    addUserBtn.style.cursor = 'not-allowed';
    addUserBtn.style.pointerEvents = 'none';

    toggleGuestBtn.style.opacity = '0.5';
    toggleGuestBtn.style.cursor = 'not-allowed';
    toggleGuestBtn.style.pointerEvents = 'none';

    toggleUserBtn.style.opacity = '0.5';
    toggleUserBtn.style.cursor = 'not-allowed';
    toggleUserBtn.style.pointerEvents = 'none';

    guestNameInput.style.opacity = '0.5';
    guestNameInput.style.cursor = 'not-allowed';

    userEmailInput.style.opacity = '0.5';
    userEmailInput.style.cursor = 'not-allowed';

    userPasswordInput.style.opacity = '0.5';
    userPasswordInput.style.cursor = 'not-allowed';
  } else {
    // Clear inline styles so CSS classes take over again
    addGuestBtn.style.opacity = '';
    addGuestBtn.style.cursor = '';
    addGuestBtn.style.pointerEvents = '';

    addUserBtn.style.opacity = '';
    addUserBtn.style.cursor = '';
    addUserBtn.style.pointerEvents = '';

    toggleGuestBtn.style.opacity = '';
    toggleGuestBtn.style.cursor = '';
    toggleGuestBtn.style.pointerEvents = '';

    toggleUserBtn.style.opacity = '';
    toggleUserBtn.style.cursor = '';
    toggleUserBtn.style.pointerEvents = '';

    guestNameInput.style.opacity = '';
    guestNameInput.style.cursor = '';

    userEmailInput.style.opacity = '';
    userEmailInput.style.cursor = '';

    userPasswordInput.style.opacity = '';
    userPasswordInput.style.cursor = '';
  }
}

// Player management functions

/**
 * Shows error message to user
 * @param message - Error message to display
 */
function showErrorMessage(message: string) {
  const errorDiv = byId<HTMLDivElement>("player-error");
  errorDiv.textContent = message;
  errorDiv.classList.remove("hidden");

  // Hide error after 5 seconds
  setTimeout(() => {errorDiv.classList.add("hidden");}, 5000);
}

/**
 * Adds an authenticated user to the tournament
 * @param email - User email
 * @param password - User password
 */
async function addAuthenticatedPlayer(email: string, password: string) {
  const max = currentMax(mode);
  if (players.length >= max) return;

  try {
    // Verify user credentials
    const userData = await verifyUserForTournament(email, password);

    // Prevent adding current user
    if (userData.id === myPlayer().id) {
      showErrorMessage(t("errorSelfAdd"));
      return;
    }

    // Prevent duplicate authenticated users by authUserId, some - whether at least on element from array
    if (players.some(p => p.authUserId === userData.id)) {
      showErrorMessage(t("errorUserAlreadyIn"));
      return;
    }

    // Create authenticated player object
    const player: Player = {
      id: `auth_${userData.id}`,
      name: userData.name,
      isAuthenticated: true,
      authUserId: userData.id
    };

    players.push(player);
    players = ensureMeFirst(players);
    plannedPairs = null;
    updateCounters();
    renderMatchmakerPreview();

    // Clear form
    byId<HTMLInputElement>("user-email").value = "";
    byId<HTMLInputElement>("user-password").value = "";

  } catch (error) {
    console.error(`${t("authFailedPrefix")}`, error);
    if (error instanceof Error) {
      showErrorMessage(error.message);
    } else {
      showErrorMessage(t("authFailedGeneric"));
    }
  }
}

/**
 * Adds a new player to the tournament
 * Validates name, prevents duplicates, and updates UI state
 * @param name - Player name to add
 */
function addPlayer(name: string) {
  const max = currentMax(mode);
  if (players.length >= max) return;

  const trimmed = name.trim();
  if (!trimmed) return;

  // Limit guest names to 9 characters to accommodate "(G)" suffix
  const finalName = trimmed.length > 9 ? trimmed.substring(0, 9) : trimmed;

  // Prevent adding current user by name
  if (finalName.toLowerCase() === myName().toLowerCase()) return;

  // Prevent duplicate players by name (case-insensitive)
  if (players.some(p => p.name.toLowerCase() === finalName.toLowerCase())) return;

  // Generate unique player ID and add to tournament
  const id = `guest_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
  players.push({ id, name: finalName, isAuthenticated: false });

  // Ensure current user is always first in the list
  players = ensureMeFirst(players);

  plannedPairs = null; // Recalculate 4-player preview if needed
  updateCounters();
  renderMatchmakerPreview();
}

/**
 * Starts the tournament and navigates to the game
 * Creates tournament seed data and stores it in localStorage
 * Handles both 2-player and 4-player tournament initialization
 */
function startTournamentAndGo() {
  // condition check
  const max = currentMax(mode);
  if (players.length !== max) return;

  // if they didn't push matchmake button yet
  if (max === 4) {
    // 4-player tournament: generate pairs if not already done
    if (!paired || !plannedPairs) {
      plannedPairs = buildFourPlayerPairs();
      paired = true;
    }
  } else {
    // 2-player tournament: deterministic pairing
    paired = true;
  }

  // Create tournament seed payload
  const payload = {
    mode,
    difficulty,
	// save the players
    players: players.map(p => ({
      id: p.id,
      name: p.name,
      isAuthenticated: p.isAuthenticated,
      authUserId: p.authUserId
    })),
    pairs: plannedPairs?.map(([a, b]) => [a.id, b.id]) ?? null,
  };

  // Store tournament configuration and navigate to game
  localStorage.setItem("tournamentSeed", JSON.stringify(payload));
  // router direct there
  window.location.hash = "#tournament";
}


// UI component builders

/**
 * Creates a vertical "vs" display block for match previews
 * @param top - Top player name
 * @param bottom - Bottom player name
 * @param highlight - Whether to apply highlight styling
 * @returns {HTMLDivElement} Styled match display element
 */
function createStackedVsBlock(top: string, bottom: string, highlight = false) {
  const wrap = document.createElement("div");
  wrap.className = "flex flex-col items-center justify-center -mt-2";

  const baseColor = "text-violet-500";
  const highlightGlow = highlight ? "drop-shadow-[0_0_6px_#9f7aea]" : "";

  // top name
  const topName = document.createElement("div");
  topName.textContent = top;
  topName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  const vs = document.createElement("div");
  vs.textContent = t("vs");
  vs.className = "text-gray-400 my-1 text-sm";

  // bottom name
  const bottomName = document.createElement("div");
  bottomName.textContent = bottom;
  bottomName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  wrap.append(topName, vs, bottomName);
  return wrap;
}

/**
 * Creates a tournament round card with match information
 * @param title - Round title (e.g., "Round 1", "Final")
 * @param top - Top player name
 * @param bottom - Bottom player name
 * @param highlight - Whether to apply highlight styling
 * @returns {HTMLDivElement} Styled round card element
 */
function makeRoundCard(title: string, top: string, bottom: string, highlight = false) {
  const card = document.createElement("div");
  card.className =
    "rounded-2xl border border-violet-400/25 p-4 bg-[#271d35] " +
    "shadow-[0_0_30px_10px_#7037d333] flex flex-col justify-start min-h-[130px]";

  const head = document.createElement("div");
  head.className = "text-base text-gray-200 mb-3 font-semibold";
  head.textContent = title;

  // create with names in it
  const names = createStackedVsBlock(top, bottom, highlight);
  card.append(head, names);
  return card;
}

// Tournament preview rendering

/**
 * - Renders the tournament match preview interface
 * - Shows participants and match cards
 */
function renderMatchmakerPreview() {
  // get the ID of the space to put there the cards
  const host = byId<HTMLDivElement>("matchgenerator");
  host.innerHTML = DOMPurify.sanitize("");

  // determine 2 or 4
  const max = currentMax(mode);

  // Participants section
  const participantsCard = document.createElement("div");
  participantsCard.className =
    "rounded-2xl border border-violet-400/20 p-4 mb-4 bg-[#271d35] shadow-[0_0_24px_4px_#7037d333]";

  // put inside host container
  host.appendChild(participantsCard);

 // put the participants title inside the cards div
  const participantsTitle = document.createElement("div");
  participantsTitle.className = "text-sm text-gray-300 mb-2";
  participantsTitle.textContent = t("participants");
  participantsCard.appendChild(participantsTitle);

  // Player chips/tags display in the tab
  const chips = document.createElement("div");
  chips.className = "flex flex-wrap gap-2";
  if (players.length) {
	// always me first
    sortForRender(players).forEach(pl => {
      const chip = document.createElement("span");

      // Different styling for authenticated vs guest users
      if (pl.isAuthenticated) {
        chip.className =
          "inline-flex items-center rounded-lg px-3 py-1 text-sm " +
          "bg-emerald-500/15 text-emerald-100 border border-emerald-400/20";
        chip.innerHTML = DOMPurify.sanitize(`${getDisplayName(pl)} <span class="ml-1">âœ“</span>`);
      } else {
        chip.className =
          "inline-flex items-center rounded-lg px-3 py-1 text-sm " +
          "bg-violet-500/15 text-violet-100 border border-violet-400/20";
        chip.textContent = getDisplayName(pl);
      }

      chips.appendChild(chip);
    });
  } else {
    const none = document.createElement("div"); //it's not going to be rendered if ensureMeFirst
    none.className = "text-base text-gray-100";
    none.textContent = t("participantsNone");
    chips.appendChild(none);
  }
  participantsCard.appendChild(chips);

  // User instruction hint
  const hint = document.createElement("div");
  hint.className = "text-xs text-gray-400 mt-3";
  hint.textContent = t("participantsHint");
  participantsCard.appendChild(hint);

  // Safety check: stop rendering if not enough players
  if (players.length < max) return;

  // Match preview cards grid coloumns
  const grid = document.createElement("div");
  grid.className = "grid gap-4 w-full md:grid-cols-3";
  host.appendChild(grid);

  if (max === 2) {
    const playerSlice = players.slice(0, 2);
    if (playerSlice.length >= 2) {
      const [a, b] = playerSlice;
      if (paired) {
		// make the card from the players name and if there is a true/no highlight on the card
        grid.appendChild(makeRoundCard(`${t("roundLabel")} 1`, getDisplayName(a!), getDisplayName(b!)));
        grid.appendChild(makeRoundCard(`${t("roundLabel")} 2`, getDisplayName(a!), getDisplayName(b!)));
        grid.appendChild(makeRoundCard(t("finalRound"), getDisplayName(a!), getDisplayName(b!), true));
      } else {
        grid.appendChild(makeRoundCard(`${t("roundLabel")} 1`, "?", "?"));
        grid.appendChild(makeRoundCard(`${t("roundLabel")} 2`, "?", "?"));
        grid.appendChild(makeRoundCard(t("finalRound"), "?", "?", true));
      }
    }
  } else {
    // 4 players
    if (paired) {
      if (!plannedPairs) plannedPairs = buildFourPlayerPairs();
      if (plannedPairs.length >= 2) {
		// pairs put into variables
        const [s1a, s1b] = plannedPairs[0]!;
        const [s2a, s2b] = plannedPairs[1]!;

        grid.appendChild(makeRoundCard(`${t("roundLabel")} 1`, getDisplayName(s1a), getDisplayName(s1b)));
        grid.appendChild(makeRoundCard(`${t("roundLabel")} 2`, getDisplayName(s2a), getDisplayName(s2b)));
      }
    } else {
      grid.appendChild(makeRoundCard(`${t("roundLabel")} 1`, "?", "?"));
      grid.appendChild(makeRoundCard(`${t("roundLabel")} 2`, "?", "?"));
    }

    grid.appendChild(makeRoundCard(t("finalRound"), "?", "?", true));

    const note = document.createElement("div");
    note.className = "text-xs text-gray-300 mt-1";
	// put instruction for the final round
    note.textContent = t("winnersNote");
    host.appendChild(note);
  }

// Let's start button, only show after Matchmaking is clicked (paired = true)
  if (paired) {
    const ctaWrap = document.createElement("div");
    ctaWrap.className = "mt-4 w-full flex justify-end"; // positioning
    const cta = document.createElement("button");
    cta.className =
      "px-5 py-2 rounded-lg bg-violet-600 hover:bg-violet-500 text-white " +
      "border border-violet-400/30 shadow-[0_0_16px_2px_#7037d355]";
    cta.textContent = t("letsStart");
	// function to go to the game area
    cta.onclick = () => startTournamentAndGo();
	// inside block to the right
    ctaWrap.appendChild(cta);
	// adds the whole block to the page
    host.appendChild(ctaWrap);
  }
}

// Page-level state management

/**
 * Resets the tournament lobby to initial state
 * Clears all players, pairs, and UI state
 */
function resetPageState() {
  players = [];
  plannedPairs = null;
  paired = false;

  players = ensureMeFirst(players);
  byId<HTMLDivElement>("matchgenerator").innerHTML = DOMPurify.sanitize("");
  renderMatchmakerPreview();
  updateCounters();
}

/**
 * Changes tournament mode and resets state
 * @param newMode - New tournament mode ("2" or "4")
 */
function setMode(newMode: "2" | "4") {
  if (mode === newMode) return;
  mode = newMode;
  resetPageState(); // Reset and re-add current user as Player 1
}

// Tournament lobby initialization
/**
 * Initializes the tournament lobby page
 * Sets up event listeners, initial state, and UI controls
 * Must be called after injecting LobbyPageTournament() HTML
 */
export function initLobbyPageTournament() {
  // Clear any existing tournament seed to ensure fresh start
  localStorage.removeItem("tournamentSeed");

  // Initialize tournament mode from radio button defaults
  mode = (document.getElementById("mode-4") as HTMLInputElement).checked ? "4" : "2";

  // Get DOM elements for event binding
  const guestInput = byId<HTMLInputElement>("guest-name");
  const addGuestBtn = byId<HTMLButtonElement>("btn-add-guest");
  const userEmailInput = byId<HTMLInputElement>("user-email");
  const userPasswordInput = byId<HTMLInputElement>("user-password");
  const addUserBtn = byId<HTMLButtonElement>("btn-add-user");
  const startBtn = byId<HTMLButtonElement>("btn-start");
  const mode2 = byId<HTMLInputElement>("mode-2");
  const mode4 = byId<HTMLInputElement>("mode-4");

  // Toggle buttons for switching between guest and user modes
  const toggleGuestBtn = byId<HTMLButtonElement>("btn-toggle-guest");
  const toggleUserBtn = byId<HTMLButtonElement>("btn-toggle-user");
  const guestInputs = byId<HTMLDivElement>("guest-inputs");
  const userInputs = byId<HTMLDivElement>("user-inputs");

  // Function to switch to guest mode, locally using guestInputs
  function showGuestMode() {
	// update html list to make it visible/hidden
    guestInputs.classList.remove('hidden');
    userInputs.classList.add('hidden');

    // Update button styles
    toggleGuestBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-violet-600 text-white border border-violet-400";
    toggleUserBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-transparent text-gray-300 border border-white/10 hover:border-violet-400";

    // Clear any error messages
    const errorDiv = byId<HTMLDivElement>("player-error");
    errorDiv.classList.add('hidden');
  }

  // Function to switch to user mode
  function showUserMode() {
    guestInputs.classList.add('hidden');
    userInputs.classList.remove('hidden');

    // Update button styles
    toggleGuestBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-transparent text-gray-300 border border-white/10 hover:border-violet-400";
    toggleUserBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-emerald-600 text-white border border-emerald-400";

    // Clear any error messages
    const errorDiv = byId<HTMLDivElement>("player-error");
    errorDiv.classList.add('hidden');
  }

// Toggle button event listeners, register to run when there's a click
  toggleGuestBtn.onclick = showGuestMode;
  toggleUserBtn.onclick = showUserMode;

  // Guest player addition, protection
  addGuestBtn.addEventListener('click', (e) => {
    e.preventDefault(); // no submit or reload
    e.stopPropagation(); // don't trigger any parent containter

    const name = guestInput.value.trim();

    if (!name) {
      showErrorMessage(t("guestUsernameRequired"));
      return;
    }

    // Validate username: only letters, max 12 characters
    if (!/^[A-Za-z]+$/.test(name)) {
      showErrorMessage(t("usernameLettersOnly"));
      return;
    }

    if (name.length > 12) {
      showErrorMessage(t("usernameMaxLen"));
      return;
    }

    addPlayer(name);
    guestInput.value = "";
  });

  // User (existing user) addition, protection
  addUserBtn.addEventListener('click', (e) => {
    e.preventDefault(); // no submit or reload
    e.stopPropagation(); // don't trigger any parent containter

    const email = userEmailInput.value.trim();
    const password = userPasswordInput.value;

    if (!email || !password) {
      showErrorMessage(t("credentialsRequired"));
      return;
    }

    if (!email.includes('@') || !email.includes('.')) {
      showErrorMessage(t("invalidEmail"));
      return;
    }

    addAuthenticatedPlayer(email, password);
  });

  // Tournament mode selection, register to run when there's a change
  mode2.onchange = () => { if (mode2.checked) setMode("2"); }; // when the user change radio button
  mode4.onchange = () => { if (mode4.checked) setMode("4"); };

  // Difficulty selection with info update
  const difficultyEasy = byId<HTMLInputElement>("difficulty-easy");
  const difficultyMedium = byId<HTMLInputElement>("difficulty-medium");
  const difficultyHard = byId<HTMLInputElement>("difficulty-hard");
  const difficultyInfo = byId<HTMLSpanElement>("difficulty-info");

  difficultyEasy.onchange = () => {
    if (difficultyEasy.checked) { difficulty = "easy"; difficultyInfo.textContent = t("difficultyInfoEasy"); }
  };
  difficultyMedium.onchange = () => {
    if (difficultyMedium.checked) { difficulty = "medium"; difficultyInfo.textContent = t("difficultyInfoMedium"); }
  };
  difficultyHard.onchange = () => {
    if (difficultyHard.checked) { difficulty = "hard"; difficultyInfo.textContent = t("difficultyInfoHard"); }
  };

  // Matchmaking button, generates tournament pairs
  startBtn.onclick = () => {
    const max = currentMax(mode);
    if (players.length !== max) return;

    if (max === 4) {
      plannedPairs = buildFourPlayerPairs(); // Generate semifinal pairs
      paired = true;
    } else {
      paired = true; // 2-player tournament is deterministic
    }
    renderMatchmakerPreview();
  };

  // Initialize with current user and render initial state, make sure it starts clean
  players = ensureMeFirst(players);
  resetPageState();
}
